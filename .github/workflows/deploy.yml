name: Deploy

on:
  push:
    branches: [main]

concurrency:
  group: deploy-prod
  cancel-in-progress: false

permissions:
  contents: read

env:
  NODE_VERSION: '20'
  TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
  TURBO_TEAM: ${{ vars.TURBO_TEAM }}
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}

jobs:
  build:
    name: Build
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version-file: '.nvmrc'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npm run db:generate --workspace=@surfaced-art/db

      - name: Build
        run: npm run build

      - name: Type Check
        run: npm run typecheck

      - name: Lint
        run: npm run lint

      - name: Test
        run: npm run test

      - name: Upload API artifact
        uses: actions/upload-artifact@v6
        with:
          name: api-dist
          path: apps/api/dist/
          retention-days: 1

  terraform:
    name: Terraform Apply (prod)
    runs-on: ubuntu-latest
    needs: build
    environment: prod

    outputs:
      lambda_function_name: ${{ steps.output.outputs.lambda_function_name }}
      api_gateway_url: ${{ steps.output.outputs.api_gateway_url }}
      ecr_repository_url: ${{ steps.output.outputs.ecr_repository_url }}

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.5'
          terraform_wrapper: false

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v6
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        working-directory: infrastructure/terraform
        run: |
          terraform init \
            -backend-config="key=prod/terraform.tfstate"

      # One-time migration: ECR repo was moved from module.lambda_api to root.
      # State mv is idempotent — no-ops silently if already at the target address.
      - name: Migrate Terraform State (ECR repo move)
        working-directory: infrastructure/terraform
        run: |
          terraform state mv \
            module.lambda_api.aws_ecr_repository.api \
            aws_ecr_repository.api 2>/dev/null || true
          terraform state mv \
            module.lambda_api.aws_ecr_lifecycle_policy.api \
            aws_ecr_lifecycle_policy.api 2>/dev/null || true

      # Bootstrap: create ECR repo before Lambda so we can push an image.
      # Lambda (package_type=Image) requires a private ECR image; public ECR URIs are invalid.
      - name: Bootstrap ECR Repository
        working-directory: infrastructure/terraform
        run: |
          terraform apply -auto-approve -input=false \
            -target=aws_ecr_repository.api \
            -target=aws_ecr_lifecycle_policy.api \
            -var-file="environments/prod.tfvars" \
            -var="db_password=${{ secrets.TF_VAR_db_password }}" \
            -var="google_client_id=${{ secrets.TF_VAR_google_client_id }}" \
            -var="google_client_secret=${{ secrets.TF_VAR_google_client_secret }}"

      - name: Login to Amazon ECR (bootstrap)
        uses: aws-actions/amazon-ecr-login@v2

      # Only push bootstrap image on first deploy (when ECR is empty).
      # Subsequent deploys already have a valid image from a previous deploy-lambda run.
      - name: Push bootstrap image to ECR if empty
        id: bootstrap
        working-directory: infrastructure/terraform
        run: |
          ECR_URL=$(terraform output -raw ecr_repository_url)
          IMAGE_COUNT=$(aws ecr describe-images \
            --repository-name surfaced-art-prod-api \
            --query 'length(imageDetails)' \
            --output text 2>/dev/null || echo "0")
          if [ "$IMAGE_COUNT" = "0" ]; then
            echo "ECR is empty — pushing bootstrap image..."
            docker pull public.ecr.aws/lambda/nodejs20.x:latest
            docker tag public.ecr.aws/lambda/nodejs20.x:latest $ECR_URL:bootstrap
            docker push $ECR_URL:bootstrap
            echo "placeholder_uri=$ECR_URL:bootstrap" >> $GITHUB_OUTPUT
          else
            echo "ECR already has $IMAGE_COUNT image(s) — skipping bootstrap"
            echo "placeholder_uri=$ECR_URL:latest" >> $GITHUB_OUTPUT
          fi

      - name: Terraform Apply
        working-directory: infrastructure/terraform
        run: |
          terraform apply -auto-approve -input=false \
            -var-file="environments/prod.tfvars" \
            -var="db_password=${{ secrets.TF_VAR_db_password }}" \
            -var="google_client_id=${{ secrets.TF_VAR_google_client_id }}" \
            -var="google_client_secret=${{ secrets.TF_VAR_google_client_secret }}" \
            -var="placeholder_image_uri=${{ steps.bootstrap.outputs.placeholder_uri }}"

      - name: Get Terraform Outputs
        id: output
        working-directory: infrastructure/terraform
        run: |
          echo "lambda_function_name=$(terraform output -raw lambda_function_name)" >> $GITHUB_OUTPUT
          echo "api_gateway_url=$(terraform output -raw api_gateway_url)" >> $GITHUB_OUTPUT
          echo "ecr_repository_url=$(terraform output -raw ecr_repository_url)" >> $GITHUB_OUTPUT

  deploy-lambda:
    name: Deploy Lambda
    runs-on: ubuntu-latest
    needs: [build, terraform]

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Download API artifact
        uses: actions/download-artifact@v7
        with:
          name: api-dist
          path: apps/api/dist/

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v6
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image
        env:
          ECR_REPOSITORY_URL: ${{ needs.terraform.outputs.ecr_repository_url }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f apps/api/Dockerfile \
            -t $ECR_REPOSITORY_URL:$IMAGE_TAG \
            -t $ECR_REPOSITORY_URL:latest \
            .
          docker push $ECR_REPOSITORY_URL:$IMAGE_TAG
          docker push $ECR_REPOSITORY_URL:latest

      - name: Deploy to Lambda
        env:
          ECR_REPOSITORY_URL: ${{ needs.terraform.outputs.ecr_repository_url }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          aws lambda update-function-code \
            --function-name ${{ needs.terraform.outputs.lambda_function_name }} \
            --image-uri $ECR_REPOSITORY_URL:$IMAGE_TAG

      - name: Wait for Lambda update
        run: |
          aws lambda wait function-updated \
            --function-name ${{ needs.terraform.outputs.lambda_function_name }}

  migrate-database:
    name: Run Migrations
    runs-on: ubuntu-latest
    needs: [terraform, deploy-lambda]

    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v6
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Run migrations via Lambda
        run: |
          aws lambda invoke \
            --function-name ${{ needs.terraform.outputs.lambda_function_name }} \
            --payload '{"command":"migrate"}' \
            --cli-binary-format raw-in-base64-out \
            /tmp/migrate-response.json

          echo "Migration response:"
          cat /tmp/migrate-response.json

          node -e "
            const r = JSON.parse(require('fs').readFileSync('/tmp/migrate-response.json', 'utf8'));
            if (!r.success) { console.error('Migration failed:', r.error); process.exit(1); }
            console.log('Migrations completed successfully');
          "

  verify:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: [terraform, deploy-lambda, migrate-database]

    steps:
      - name: Health Check
        run: |
          API_URL="${{ needs.terraform.outputs.api_gateway_url }}"
          echo "Checking health at $API_URL/health"

          for i in {1..5}; do
            response=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL/health")
            if [ "$response" == "200" ]; then
              echo "Health check passed!"
              exit 0
            fi
            echo "Attempt $i: Got $response, retrying..."
            sleep 5
          done

          echo "Health check failed after 5 attempts"
          exit 1
