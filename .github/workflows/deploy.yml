name: Deploy

on:
  push:
    branches: [main]

concurrency:
  group: deploy-prod
  cancel-in-progress: false

permissions:
  contents: read

env:
  NODE_VERSION: '20'
  TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
  TURBO_TEAM: ${{ vars.TURBO_TEAM }}
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
  # Bootstrap image: pulled and pushed to private ECR on first deploy so Lambda has a valid
  # image URI at creation time. This is the single source of truth for the base image digest.
  # The Terraform placeholder_image_uri variable default mirrors this value for local runs only;
  # CI always overrides it via -var. To refresh the digest: bash scripts/get-lambda-bootstrap-digest.sh
  LAMBDA_BOOTSTRAP_IMAGE: 'public.ecr.aws/lambda/nodejs@sha256:b1d950b97aaedc054c6c9c5409c98cf5c8f29de370a6f344113e1aeeaa441707'

jobs:
  build:
    name: Build
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version-file: '.nvmrc'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npm run db:generate --workspace=@surfaced-art/db

      - name: Build
        run: npm run build

      - name: Type Check
        run: npm run typecheck

      - name: Lint
        run: npm run lint

      - name: Test
        run: npm run test

      - name: Upload API artifact
        uses: actions/upload-artifact@v6
        with:
          name: api-dist
          path: apps/api/dist/
          retention-days: 1

  terraform:
    name: Terraform Apply (prod)
    runs-on: ubuntu-latest
    needs: build
    environment: prod

    outputs:
      lambda_function_name: ${{ steps.output.outputs.lambda_function_name }}
      api_gateway_url: ${{ steps.output.outputs.api_gateway_url }}
      ecr_repository_url: ${{ steps.output.outputs.ecr_repository_url }}

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.5'
          terraform_wrapper: false

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v6
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        working-directory: infrastructure/terraform
        run: |
          terraform init \
            -backend-config="key=prod/terraform.tfstate"

      # Bootstrap: create ECR repo before Lambda so we can push an image.
      # Lambda (package_type=Image) requires a private ECR image; public ECR URIs are invalid.
      - name: Bootstrap ECR Repository
        working-directory: infrastructure/terraform
        run: |
          terraform apply -auto-approve -input=false \
            -target=aws_ecr_repository.api \
            -target=aws_ecr_lifecycle_policy.api \
            -target=aws_ecr_repository_policy.api \
            -var-file="environments/prod.tfvars" \
            -var="db_password=${{ secrets.TF_VAR_db_password }}" \
            -var="google_client_id=${{ secrets.TF_VAR_google_client_id }}" \
            -var="google_client_secret=${{ secrets.TF_VAR_google_client_secret }}" \
            -var="placeholder_image_uri=${{ env.LAMBDA_BOOTSTRAP_IMAGE }}"

      - name: Login to Amazon ECR (bootstrap)
        uses: aws-actions/amazon-ecr-login@v2

      # Only push bootstrap image on first deploy (when ECR is empty).
      # Subsequent deploys already have a valid image from a previous deploy-lambda run.
      - name: Push bootstrap image to ECR if empty
        id: bootstrap
        working-directory: infrastructure/terraform
        run: |
          ECR_URL=$(terraform output -raw ecr_repository_url)
          ECR_REPO="${ECR_URL##*/}"
          IMAGE_COUNT=$(aws ecr describe-images \
            --repository-name "$ECR_REPO" \
            --query 'length(imageDetails)' \
            --output text 2>/dev/null || echo "0")
          if [ "$IMAGE_COUNT" = "0" ]; then
            echo "ECR is empty — pushing bootstrap image..."
            docker pull "$LAMBDA_BOOTSTRAP_IMAGE"
            docker tag "$LAMBDA_BOOTSTRAP_IMAGE" "$ECR_URL:bootstrap"
            docker push "$ECR_URL:bootstrap"
            echo "placeholder_uri=$ECR_URL:bootstrap" >> "$GITHUB_OUTPUT"
          else
            # ECR has images. Prefer :latest (set by deploy-lambda on successful deploys).
            # Fall back to :bootstrap if deploy-lambda has never completed successfully.
            if aws ecr describe-images \
                --repository-name "$ECR_REPO" \
                --image-ids imageTag=latest &>/dev/null; then
              echo "ECR has :latest — using it as placeholder"
              echo "placeholder_uri=$ECR_URL:latest" >> "$GITHUB_OUTPUT"
            else
              echo "ECR has images but no :latest yet — using :bootstrap as placeholder"
              echo "placeholder_uri=$ECR_URL:bootstrap" >> "$GITHUB_OUTPUT"
            fi
          fi

      - name: Terraform Apply
        working-directory: infrastructure/terraform
        run: |
          terraform apply -auto-approve -input=false \
            -var-file="environments/prod.tfvars" \
            -var="db_password=${{ secrets.TF_VAR_db_password }}" \
            -var="google_client_id=${{ secrets.TF_VAR_google_client_id }}" \
            -var="google_client_secret=${{ secrets.TF_VAR_google_client_secret }}" \
            -var="placeholder_image_uri=${{ steps.bootstrap.outputs.placeholder_uri }}"

      - name: Get Terraform Outputs
        id: output
        working-directory: infrastructure/terraform
        run: |
          echo "lambda_function_name=$(terraform output -raw lambda_function_name)" >> $GITHUB_OUTPUT
          echo "api_gateway_url=$(terraform output -raw api_gateway_url)" >> $GITHUB_OUTPUT
          echo "ecr_repository_url=$(terraform output -raw ecr_repository_url)" >> $GITHUB_OUTPUT

  deploy-lambda:
    name: Deploy Lambda
    runs-on: ubuntu-latest
    needs: [build, terraform]

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Download API artifact
        uses: actions/download-artifact@v7
        with:
          name: api-dist
          path: apps/api/dist/

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v6
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build Docker image
        env:
          ECR_REPOSITORY_URL: ${{ needs.terraform.outputs.ecr_repository_url }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f apps/api/Dockerfile \
            -t $ECR_REPOSITORY_URL:$IMAGE_TAG \
            -t $ECR_REPOSITORY_URL:latest \
            .

      - name: Validate container contents
        env:
          ECR_REPOSITORY_URL: ${{ needs.terraform.outputs.ecr_repository_url }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "Checking container has required files..."
          docker run --rm --entrypoint="" $ECR_REPOSITORY_URL:$IMAGE_TAG \
            sh -c "
              set -e
              echo '--- Handler bundle ---'
              ls -la /var/task/index.js
              echo '--- Prisma CLI ---'
              ls -la /var/task/packages/db/node_modules/prisma/build/index.js
              echo '--- Prisma schema ---'
              ls -la /var/task/prisma/schema.prisma
              echo '--- Prisma migrations ---'
              ls /var/task/prisma/migrations/
              echo 'All required files present.'
            "

      - name: Push Docker image
        env:
          ECR_REPOSITORY_URL: ${{ needs.terraform.outputs.ecr_repository_url }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker push $ECR_REPOSITORY_URL:$IMAGE_TAG
          docker push $ECR_REPOSITORY_URL:latest

      - name: Deploy to Lambda
        env:
          ECR_REPOSITORY_URL: ${{ needs.terraform.outputs.ecr_repository_url }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          aws lambda update-function-code \
            --function-name ${{ needs.terraform.outputs.lambda_function_name }} \
            --image-uri $ECR_REPOSITORY_URL:$IMAGE_TAG

      - name: Wait for Lambda update
        run: |
          aws lambda wait function-updated \
            --function-name ${{ needs.terraform.outputs.lambda_function_name }}

  migrate-database:
    name: Run Migrations
    runs-on: ubuntu-latest
    needs: [terraform, deploy-lambda]

    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v6
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Run migrations via Lambda
        run: |
          aws lambda invoke \
            --function-name ${{ needs.terraform.outputs.lambda_function_name }} \
            --payload '{"command":"migrate"}' \
            --cli-binary-format raw-in-base64-out \
            /tmp/migrate-response.json

          echo "Migration response:"
          cat /tmp/migrate-response.json

          node -e "
            const r = JSON.parse(require('fs').readFileSync('/tmp/migrate-response.json', 'utf8'));
            if (!r.success) { console.error('Migration failed:', r.error); process.exit(1); }
            console.log('Migrations completed successfully');
          "

  verify:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: [terraform, deploy-lambda, migrate-database]

    steps:
      - name: Health Check
        run: |
          API_URL="${{ needs.terraform.outputs.api_gateway_url }}"
          echo "Checking health at $API_URL/health"

          for i in {1..5}; do
            response=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL/health")
            if [ "$response" == "200" ]; then
              echo "Health check passed!"
              exit 0
            fi
            echo "Attempt $i: Got $response, retrying..."
            sleep 5
          done

          echo "Health check failed after 5 attempts"
          exit 1
