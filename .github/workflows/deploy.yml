name: Deploy

on:
  push:
    branches: [main]

concurrency:
  group: deploy-prod
  cancel-in-progress: false

permissions:
  contents: read

env:
  NODE_VERSION: '20'
  TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
  TURBO_TEAM: ${{ vars.TURBO_TEAM }}
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
  # Bootstrap image: pulled and pushed to private ECR on first deploy so Lambda has a valid
  # image URI at creation time. This is the single source of truth for the base image digest.
  # The Terraform placeholder_image_uri variable default mirrors this value for local runs only;
  # CI always overrides it via -var. To refresh the digest: bash scripts/get-lambda-bootstrap-digest.sh
  LAMBDA_BOOTSTRAP_IMAGE: 'public.ecr.aws/lambda/nodejs@sha256:b1d950b97aaedc054c6c9c5409c98cf5c8f29de370a6f344113e1aeeaa441707'

jobs:
  build:
    name: Build
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version-file: '.nvmrc'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build
        run: npm run build

      - name: Type Check
        run: npm run typecheck

      - name: Lint
        run: npm run lint

      - name: Test
        run: npm run test

      - name: Upload API artifact
        uses: actions/upload-artifact@v6
        with:
          name: api-dist
          path: apps/api/dist/
          retention-days: 1

      - name: Upload migrate artifact
        uses: actions/upload-artifact@v6
        with:
          name: migrate-dist
          path: tools/migrate/dist/
          retention-days: 1

  terraform:
    name: Terraform Apply (prod)
    runs-on: ubuntu-latest
    needs: build
    environment: prod

    outputs:
      lambda_function_name: ${{ steps.output.outputs.lambda_function_name }}
      migrate_function_name: ${{ steps.output.outputs.migrate_function_name }}
      api_gateway_url: ${{ steps.output.outputs.api_gateway_url }}
      ecr_repository_url: ${{ steps.output.outputs.ecr_repository_url }}
      migrate_ecr_repository_url: ${{ steps.output.outputs.migrate_ecr_repository_url }}

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.5'
          terraform_wrapper: false

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v6
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        working-directory: infrastructure/terraform
        run: |
          terraform init \
            -backend-config="key=prod/terraform.tfstate"

      # Bootstrap: create ECR repos before Lambdas so we can push images.
      # Lambda (package_type=Image) requires a private ECR image; public ECR URIs are invalid.
      - name: Bootstrap ECR Repositories
        working-directory: infrastructure/terraform
        run: |
          terraform apply -auto-approve -input=false \
            -target=aws_ecr_repository.api \
            -target=aws_ecr_lifecycle_policy.api \
            -target=aws_ecr_repository_policy.api \
            -target=aws_ecr_repository.migrate \
            -target=aws_ecr_lifecycle_policy.migrate \
            -target=aws_ecr_repository_policy.migrate \
            -var-file="environments/prod.tfvars" \
            -var="db_password=${{ secrets.TF_VAR_db_password }}" \
            -var="google_client_id=${{ secrets.TF_VAR_google_client_id }}" \
            -var="google_client_secret=${{ secrets.TF_VAR_google_client_secret }}" \
            -var="alert_email_address=${{ secrets.TF_VAR_alert_email_address }}" \
            -var="placeholder_image_uri=${{ env.LAMBDA_BOOTSTRAP_IMAGE }}"

      - name: Login to Amazon ECR (bootstrap)
        uses: aws-actions/amazon-ecr-login@v2

      # Push bootstrap image to any empty ECR repos on first deploy.
      # Subsequent deploys already have valid images from previous deploy-lambdas runs.
      - name: Push bootstrap image to ECR repos if empty
        id: bootstrap
        working-directory: infrastructure/terraform
        run: |
          API_ECR_URL=$(terraform output -raw ecr_repository_url)
          MIGRATE_ECR_URL=$(terraform output -raw migrate_ecr_repository_url)

          push_bootstrap_if_empty() {
            local ecr_url="$1"
            local label="$2"
            local ecr_repo="${ecr_url##*/}"
            local image_count

            image_count=$(aws ecr describe-images \
              --repository-name "$ecr_repo" \
              --query 'length(imageDetails)' \
              --output text 2>/dev/null || echo "0")

            if [ "$image_count" = "0" ]; then
              echo "$label ECR is empty — pushing bootstrap image..."
              docker tag "$LAMBDA_BOOTSTRAP_IMAGE" "$ecr_url:bootstrap"
              docker push "$ecr_url:bootstrap"
            fi
          }

          # Pull bootstrap image once, push to any empty ECR repos
          docker pull "$LAMBDA_BOOTSTRAP_IMAGE"
          push_bootstrap_if_empty "$API_ECR_URL" "API"
          push_bootstrap_if_empty "$MIGRATE_ECR_URL" "Migrate"

          # Determine placeholder URI for Terraform (API ECR as source of truth).
          # Both Lambda modules share this same placeholder_image_uri on initial
          # creation only. After first deploy, lifecycle { ignore_changes = [image_uri] }
          # takes over and CI manages each Lambda's image independently.
          API_ECR_REPO="${API_ECR_URL##*/}"
          if aws ecr describe-images \
              --repository-name "$API_ECR_REPO" \
              --image-ids imageTag=latest &>/dev/null; then
            echo "API ECR has :latest — using as placeholder"
            echo "placeholder_uri=$API_ECR_URL:latest" >> "$GITHUB_OUTPUT"
          elif aws ecr describe-images \
              --repository-name "$API_ECR_REPO" \
              --image-ids imageTag=bootstrap &>/dev/null; then
            echo "API ECR has :bootstrap — using as placeholder"
            echo "placeholder_uri=$API_ECR_URL:bootstrap" >> "$GITHUB_OUTPUT"
          else
            # Neither :latest nor :bootstrap exists (repo has only custom tags).
            # Push :bootstrap so the placeholder URI points to a real image.
            echo "No :latest or :bootstrap — pushing :bootstrap now"
            docker tag "$LAMBDA_BOOTSTRAP_IMAGE" "$API_ECR_URL:bootstrap"
            docker push "$API_ECR_URL:bootstrap"
            echo "placeholder_uri=$API_ECR_URL:bootstrap" >> "$GITHUB_OUTPUT"
          fi

      - name: Terraform Apply
        working-directory: infrastructure/terraform
        run: |
          terraform apply -auto-approve -input=false \
            -var-file="environments/prod.tfvars" \
            -var="db_password=${{ secrets.TF_VAR_db_password }}" \
            -var="google_client_id=${{ secrets.TF_VAR_google_client_id }}" \
            -var="google_client_secret=${{ secrets.TF_VAR_google_client_secret }}" \
            -var="alert_email_address=${{ secrets.TF_VAR_alert_email_address }}" \
            -var="placeholder_image_uri=${{ steps.bootstrap.outputs.placeholder_uri }}"

      - name: Get Terraform Outputs
        id: output
        working-directory: infrastructure/terraform
        run: |
          echo "lambda_function_name=$(terraform output -raw lambda_function_name)" >> $GITHUB_OUTPUT
          echo "migrate_function_name=$(terraform output -raw migrate_function_name)" >> $GITHUB_OUTPUT
          echo "api_gateway_url=$(terraform output -raw api_gateway_url)" >> $GITHUB_OUTPUT
          echo "ecr_repository_url=$(terraform output -raw ecr_repository_url)" >> $GITHUB_OUTPUT
          echo "migrate_ecr_repository_url=$(terraform output -raw migrate_ecr_repository_url)" >> $GITHUB_OUTPUT

  deploy-lambdas:
    name: Deploy Lambdas
    runs-on: ubuntu-latest
    needs: [build, terraform]

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Download API artifact
        uses: actions/download-artifact@v7
        with:
          name: api-dist
          path: apps/api/dist/

      - name: Download migrate artifact
        uses: actions/download-artifact@v7
        with:
          name: migrate-dist
          path: tools/migrate/dist/

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v6
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      # --- API Lambda ---

      - name: Build API Docker image
        env:
          ECR_REPOSITORY_URL: ${{ needs.terraform.outputs.ecr_repository_url }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f apps/api/Dockerfile \
            -t $ECR_REPOSITORY_URL:$IMAGE_TAG \
            -t $ECR_REPOSITORY_URL:latest \
            .

      # Paths validated here must match the Dockerfile layout (apps/api/Dockerfile).
      - name: Validate API container
        env:
          ECR_REPOSITORY_URL: ${{ needs.terraform.outputs.ecr_repository_url }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "Checking API container has required files..."
          docker run --rm --entrypoint="" \
            $ECR_REPOSITORY_URL:$IMAGE_TAG \
            sh -c '
              ok=true
              for f in /var/task/index.js; do
                if test -f "$f"; then
                  echo "OK   $f"
                else
                  echo "MISSING $f" >&2; ok=false
                fi
              done
              # Verify Prisma WASM query compiler chunks were copied
              count=$(ls /var/task/query_compiler_fast_bg.postgresql*.js 2>/dev/null | wc -l)
              if [ "$count" -ge 1 ]; then
                echo "OK   Prisma WASM chunks ($count files)"
              else
                echo "MISSING Prisma WASM chunks (query_compiler_fast_bg.postgresql*.js)" >&2; ok=false
              fi
              $ok && echo "All required files present." || { echo "Validation failed" >&2; exit 1; }
            '

      - name: Push API Docker image
        env:
          ECR_REPOSITORY_URL: ${{ needs.terraform.outputs.ecr_repository_url }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker push $ECR_REPOSITORY_URL:$IMAGE_TAG
          docker push $ECR_REPOSITORY_URL:latest

      - name: Deploy API Lambda
        env:
          ECR_REPOSITORY_URL: ${{ needs.terraform.outputs.ecr_repository_url }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          aws lambda update-function-code \
            --function-name ${{ needs.terraform.outputs.lambda_function_name }} \
            --image-uri $ECR_REPOSITORY_URL:$IMAGE_TAG

      # --- Migration Lambda ---

      # Build context must be monorepo root (.) because the Dockerfile COPYs
      # package.json, package-lock.json, and workspace manifests from the root.
      - name: Build migrate Docker image
        env:
          ECR_REPOSITORY_URL: ${{ needs.terraform.outputs.migrate_ecr_repository_url }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f tools/migrate/Dockerfile \
            -t $ECR_REPOSITORY_URL:$IMAGE_TAG \
            -t $ECR_REPOSITORY_URL:latest \
            .

      # Paths validated here must match the Dockerfile layout (tools/migrate/Dockerfile)
      # and the runtime constants in tools/migrate/src/index.ts (PRISMA_CLI path).
      - name: Validate migrate container
        env:
          ECR_REPOSITORY_URL: ${{ needs.terraform.outputs.migrate_ecr_repository_url }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "Checking migrate container has required files..."
          docker run --rm --entrypoint="" \
            $ECR_REPOSITORY_URL:$IMAGE_TAG \
            sh -c '
              ok=true
              for f in \
                /var/task/index.js \
                /var/task/node_modules/prisma/build/index.js \
                /var/task/prisma/schema.prisma \
                /var/task/prisma.config.ts; do
                if test -f "$f"; then
                  echo "OK   $f"
                else
                  echo "MISSING $f" >&2; ok=false
                fi
              done
              if ! test -d /var/task/prisma/migrations; then
                echo "MISSING /var/task/prisma/migrations/" >&2; ok=false
              else
                echo "OK   /var/task/prisma/migrations/"
              fi
              $ok && echo "All required files present." || { echo "Validation failed" >&2; exit 1; }
            '

      - name: Push migrate Docker image
        env:
          ECR_REPOSITORY_URL: ${{ needs.terraform.outputs.migrate_ecr_repository_url }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker push $ECR_REPOSITORY_URL:$IMAGE_TAG
          docker push $ECR_REPOSITORY_URL:latest

      - name: Deploy migrate Lambda
        env:
          ECR_REPOSITORY_URL: ${{ needs.terraform.outputs.migrate_ecr_repository_url }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          aws lambda update-function-code \
            --function-name ${{ needs.terraform.outputs.migrate_function_name }} \
            --image-uri $ECR_REPOSITORY_URL:$IMAGE_TAG

      # --- Wait for both updates ---

      - name: Wait for Lambda updates
        run: |
          aws lambda wait function-updated \
            --function-name ${{ needs.terraform.outputs.lambda_function_name }}
          aws lambda wait function-updated \
            --function-name ${{ needs.terraform.outputs.migrate_function_name }}

  migrate-database:
    name: Run Migrations
    runs-on: ubuntu-latest
    needs: [terraform, deploy-lambdas]

    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v6
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Run migrations via Lambda
        run: |
          aws lambda invoke \
            --function-name ${{ needs.terraform.outputs.migrate_function_name }} \
            --payload '{"command":"migrate"}' \
            --cli-binary-format raw-in-base64-out \
            /tmp/migrate-response.json

          echo "Migration response:"
          cat /tmp/migrate-response.json

          node -e "
            const r = JSON.parse(require('fs').readFileSync('/tmp/migrate-response.json', 'utf8'));
            if (!r.success) { console.error('Migration failed:', r.error); process.exit(1); }
            console.log('Migrations completed successfully');
          "

  verify:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: [terraform, deploy-lambdas, migrate-database]

    steps:
      - name: Health Check
        run: |
          API_URL="${{ needs.terraform.outputs.api_gateway_url }}"
          echo "Checking health at $API_URL/health"

          for i in {1..5}; do
            response=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL/health")
            if [ "$response" == "200" ]; then
              echo "Health check passed!"
              exit 0
            fi
            echo "Attempt $i: Got $response, retrying..."
            sleep 5
          done

          echo "Health check failed after 5 attempts"
          exit 1
